<!DOCTYPE html>
<meta charset='utf-8'>
<title>Network Information API</title>
<script class='remove' src='//www.w3.org/Tools/respec/respec-w3c-common'></script>
<script>
function loadTableData() {
  return fetch("downlink.json")
    .then(res => res.json())
    .then(populateTable)
    .catch(err => {
      console.error("Error trying to get downlink.json", err);
      populateTable({});
    });
}

function populateTable(data) {
  const tbody = document.querySelector("#max-downlink-table > tbody");
  const head = document.querySelector("#max-downlink-table > thead");
  const headsize = head.rows[0].children.length;
  let trs = "";
  //for each entry in the JSON
  for (var connection in data) {
    var connectionTypes = data[connection];
    trs += "<tr>";
    trs += connectionTypes.length > 1
      ? "<td rowspan=" + connectionTypes.length + ">"
      : "<td>";
    trs += "<a>" + connection + "</a>";
    trs += "</td>";

    //Tell reader we don't have any data for connection
    if (connectionTypes.length === 0) {
      trs += "<td colspan=" + headsize + ">";
      trs += "No data available for this";
      trs += " <a>connection type</a>.</td>";
    } else {
      //loop through and populate the table
      for (var j = 0; j < connectionTypes.length; j++) {
        var conObj = connectionTypes[j];
        if (j) {
          trs += "<tr>";
        }
        trs += "<td>" + conObj.name + "</td>";
        trs += "<td>" + conObj.version + "</td>";
        trs += "<td>" + conObj.max.downlink + "</td>";
        trs += "</tr>";
      }
    }
  }
  //finally, add the data
  tbody.innerHTML = trs;
}

var respecConfig = {
  specStatus: "CG-DRAFT",
  shortName: "netinfo-api",
  format: "markdown",
  subtitle: "Living Document",
  github: "https://github.com/WICG/netinfo/",
  editors: [
    {
      name: "Ilya Grigorik",
      company: "Google",
      companyURL: "http://google.com",
    },
    {
      name: "Marcos Cáceres",
      company: "Mozilla Corporation",
      companyURL: "http://mozilla.com",
    },
    {
      name: "Fernando Jiménez Moreno",
      company: "Telefonica",
      companyURL: "http://www.telefonica.com/en/home/jsp/home.jsp",
    },
  ],
  wg: "Web Incubator Community Group",
  wgURI: "https://wicg.io",
  otherLinks: [
    {
      key: "Implementations",
      data: [
        {
          value: "Chromium",
          href: "https://code.google.com/p/chromium/issues/detail?id=368358",
        },
      ],
    },
  ],
  preProcess: [loadTableData],
};
</script>

<section id='abstract'>
  The <cite>Network Information API</cite> enables web applications to access information about the network connection in use by the device.
</section>

<section id='sotd'></section>

## Use cases and requirements

This document attempts to address the <a data-cite="netinfo-usecases#requirements">requirements</a> from the <a data-cite="netinfo-usecases">Review of Apps that Use Network Information</a>. Those are:

 * Provide access to the <a>connection type</a> the system is using to communicate with the network (e.g., cellular, bluetooth, ethernet, wifi, other, or none). This information needs to be available either immediately on page load or as close as possible to it.
 * Provide a means for scripts to be notified if the <a>connection type</a> changes. This is to allow developers to make dynamic changes to the DOM and/or inform the user that the network <a>connection type</a> has changed (and that it could impact them in some way).

<section class="informative">
  ## Examples of usage
  For examples of the kinds of applications one can build with this API, see the <cite>[Review of Apps that Use Network Information](https://github.com/w3c-webmob/netinfo)</cite>.

  <pre class="example js">
    // Get the connection type.
    var type = navigator.connection.type;

    // Get an upper bound on the downlink speed of the first network hop
    var max = navigator.connection.downlinkMax;

    function changeHandler(e) {
      // Handle change to connection here.
    }

    // Register for event changes.
    navigator.connection.onchange = changeHandler;

    // Alternatively.
    navigator.connection.addEventListener('change', changeHandler);
  </pre>
</section>


## Definitions

For clarity, a <dfn>megabit</dfn> is 1,000,000 bits, and <dfn data-lt="Mbit/s">megabits per second</dfn> is equivalent to transferring:

  * 1,000,000 bits per second
  * 1,000 kilobits per second
  * 125,000 bytes per second
  * 125 kilobytes per second
  * and so on...


## Connection types

### Underlying connection technology

This section defines the <dfn data-lt="connection type">connection types</dfn> and the <a>underlying connection technology</a> that the <a>user agent</a> is using (if any):

<dl data-dfn-for="ConnectionType">
  <dt><dfn>bluetooth</dfn></dt>
  <dd>A Bluetooth connection.</dd>
  <dt><dfn>cellular</dfn></dt>
  <dd>A cellular connection (e.g., EDGE, HSPA, LTE, etc.).</dd>
  <dt><dfn>ethernet</dfn></dt>
  <dd>An Ethernet connection.</dd>
  <dt><dfn>none</dfn></dt>
  <dd>No network connection. The user agent will not contact the network when the user follows links or when a script requests a remote page (or knows that such an attempt would fail) - i.e., equivalent to `navigator.onLine === false` in HTML.</dd>
  <dt><dfn>mixed</dfn></dt>
  <dd>The user agent is using multiple connection types.</dd>
  <dt><dfn>other</dfn></dt>
  <dd>The connection type that is known, but not one of enumerated connection types.</dd>
  <dt><dfn>unknown</dfn></dt>
  <dd>The user agent has established a network connection, but is unable, or unwilling, to determine the <a>underlying connection technology</a>.</dd>
  <dt><dfn>wifi</dfn></dt>
  <dd>A Wi-Fi connection.</dd>
  <dt><dfn>wimax</dfn></dt>
  <dd>A WiMAX connection.</dd>
</dl>

The <a>connection types</a> are represented in this API by the <a>ConnectionType</a> enum.

### <dfn>ConnectionType</dfn> enum

<pre class="idl">
  enum ConnectionType {
    "bluetooth",
    "cellular",
    "ethernet",
    "mixed",
    "none",
    "other",
    "unknown",
    "wifi",
    "wimax"
  };
</pre>

### Effective connection types

This section defines the <dfn data-lt="effective connection type">effective connection types</dfn> (ECT):

<table id="effective-connection-type-table" data-dfn-for="EffectiveConnectionType">
  <caption><dfn>Table of effective connection types</dfn></caption>
  <thead>
    <tr>
      <th>ECT</th>
      <th>Minimum RTT (ms)</th>
      <th>Maximum downlink (Kbps)</th>
      <th>Explanation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><dfn>slow-2g</dfn></td>
      <td>1900</td>
      <td>50</td>
      <td>The network is suited for small transfers only such as text-only pages.</td>
    </tr>
    <tr>
      <td><dfn>2g</dfn></td>
      <td>1300</td>
      <td>70</td>
      <td>The network is suited for transfers of small images.</td>
    </tr>
    <tr>
      <td><dfn>3g</dfn></td>
      <td>200</td>
      <td>700</td>
      <td>The network is suited for transfers of large assets such as high resolution images, audio, and SD video.</td>
    </tr>
    <tr>
      <td><dfn>4g</dfn></td>
      <td>0</td>
      <td>∞</td>
      <td>The network is suited for HD video, real-time video, etc.</td>
    </tr>
  </tbody>
</table>

The above round-trip and bandwidth values are based on real user measurement observations:

  * `slow-2g` is the 66.6th percentile of 2G observations
  * `2g` is the 50th percentile of 2G observations
  * `3g` is the 50th percentile of 3G observations

The absolute values provided above are based on real user measurement on Chrome on Android, as captured in April 2017. The user agent MAY update these values in the future to reflect changes in the measurement data.

The <a>effective connection types</a> are represented in this API by the <a>EffectiveConnectionType</a> enum.

### <dfn>EffectiveConnectionType</dfn> enum

<pre class="idl">
  enum EffectiveConnectionType {
    "2g",
    "3g",
    "4g",
    "slow-2g"
  };
</pre>


## <dfn>NavigatorNetworkInformation</dfn> interface

The `NavigatorNetworkInformation` interface exposes access to <a>`NetworkInformation`</a> interface by extending the <code><dfn data-cite="!HTML#navigator">Navigator</dfn></code> and <code><dfn data-cite="!HTML#workernavigator">WorkerNavigator</dfn></code> interface.

<pre class="idl">
  [NoInterfaceObject, Exposed=(Window,Worker)]
  interface NavigatorNetworkInformation {
    readonly attribute NetworkInformation connection;
  };

  Navigator implements NavigatorNetworkInformation;
  WorkerNavigator implements NavigatorNetworkInformation;
</pre>

<section data-dfn-for="NavigatorNetworkInformation">
  ### <dfn>connection</dfn> attribute

  The `connection` attribute, when getting, returns an object that implements the <a>NetworkInformation</a> interface.
</section>

<section data-dfn-for="NetworkInformation">
  ## <dfn>NetworkInformation</dfn> interface

  The `NetworkInformation` interface provides a means to access information about the network connection the user agent is currently using. The <code><dfn data-cite="DOM#interface-eventtarget">EventTarget</dfn></code> is defined in [[!DOM]]. 

  <pre class="idl">
  [Exposed=(Window,Worker)]
  interface NetworkInformation : EventTarget {
    readonly attribute ConnectionType type;
    readonly attribute EffectiveConnectionType effectiveType;
    readonly attribute Megabit downlinkMax;
    readonly attribute Megabit downlink;
    readonly attribute Millisecond rtt;
    attribute EventHandler onchange;
  };

  typedef unrestricted double Megabit;
  typedef unsigned long long Millisecond;
  </pre>

  ### <dfn>type</dfn> attribute
  
  The `type` attribute, when getting, returns the <a>connection type</a> that the user agent is using.

  ### <dfn>effectiveType</dfn> attribute
  
  The `effectiveType` attribute, when getting, returns the <a>effective connection type</a> that is determined using a combination of recently observed round trip times and downlink bandwidth.

  ### <dfn>downlinkMax</dfn> attribute
  
  The `downlinkMax` attribute represents an <dfn>upper bound on the downlink speed of the first network hop</dfn>. The reported value is in <a>megabits per second</a> and determined by the properties of the <a>underlying connection technology</a>.

  <div class="note">
    The user agent has no knowledge of the total number or the performance characteristics of the various network hops required to fulfill a particular request; different requests may follow different routes and have different performance characteristics. The reported <a>upper bound on the downlink speed of the first network hop</a> value is determined by the properties of the <a>underlying connection technology</a> of the first network hop. The end-to-end performance of any request cannot exceed this value, but it is also not a guarantee of performance and may be significantly worse.
  </div>

  ### <dfn>onchange</dfn> attribute
  
  The `onchange` event handler attribute handles "change" events fired during the <a>steps to update the connection values</a>.

  ### <dfn>downlink</dfn> attribute
  
  The `downlink` attribute represents the effective bandwidth estimate in <a>megabits per second</a> based on recently observed throughput on the client, rounded to nearest 25 kilobits per second.

  ### <dfn>rtt</dfn> attribute
  
  The `rtt` attribute represents the effective round-trip time estimate in <dfn data-lt="Millisecond">milliseconds</dfn> based on recently observed round-trip times on the client, rounded to nearest 25 milliseconds.
  
</section>


## Underlying connection technology

The relationship between an <dfn>underlying connection technology</dfn> and its <a>upper bound on the downlink speed of the first network hop</a> is determined by the available network interfaces that may be used to fulfill new network requests.

The <dfn>downlinkMax for an available interface</dfn> is determined via the standardized, or generally accepted, maximum download data rate captured in the <a>table of maximum downlink speeds</a>. Where possible, this value may be refined to report a more accurate upper bound based on current properties of the interface - e.g. signal strength, modulation algorithm, and other "network weather" variables.

The <a>upper bound on the downlink speed of the first network hop</a> is determined by the rules described in <a href="#handling-changes-to-the-underlying-connection">handling changes to the underlying connection</a>.

<div class="note">
  The enumeration of available network interfaces and their generation and version is not directly exposed to script. Instead, `downlinkMax` exposes a single value in <a>megabits per second</a> that accounts for all available interfaces and their current network conditions.
</div>

<table id="max-downlink-table" class="simple" data-link-for="ConnectionType">
  <caption><dfn>Table of maximum downlink speeds</dfn></caption>
  <thead>
    <tr>
      <th>Connection type</th>
      <th>Underlying connection technology</th>
      <th>Generation or Version</th>
      <th>Max downlink speed (<a>Mbit/s</a>)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <!-- fallback if JS disabled or xhr fails -->
      <td colspan="4"><a href="downlink.json">Data available as JSON</a>.</td>
    </tr>
  </tbody>
</table>

<section data-link-for="NetworkInformation">
### Handling changes to the underlying connection

When the properties of the <a>underlying connection technology</a> change, due to a switch to a different <a>connection type</a> or <a>effective connection type</a>, change in <a>upper bound on the downlink speed of the first network hop</a>, or change in effective <a>downlink</a> or <a>rtt</a> estimates, the user agent MUST run the <dfn>steps to update the connection values</dfn>:

  1. Let <var>new-type</var> be the <a>connection type</a> that represents the <a>underlying connection technology</a>.
  1. Let <var>new-effective-type</var> be the <a>effective connection type</a> determined by current <a>downlink</a> and <a>rtt</a> values.
  1. Let <var>new-downlink</var> be the <a>downlink</a> value.
  1. Let <var>new-rtt</var> be the <a>rtt</a> value.
  1. If <var>new-type</var> is "none", set <var>max-value</var> to `0`.
  1. if <var>new-type</var> is "unknown", set <var>max-value</var> to `+Infinity`.
  1. If <var>new-type</var> is "mixed", set <var>max-value</var> to an applicable value for the interface configuration used to service new network requests - e.g. if multiple interfaces may be used, sum their <a>downlinkMax for an available interface</a> values.
  1. Otherwise, set <var>max-value</var> to <a>downlinkMax for an available interface</a>.
  1. If <var>max-value</var> is not equal to the value of `connection.downlinkMax`, or if <var>new-type</var> is not equal to the value of `connection.type`, or if <var>new-downlink</var> is not equal to the value of `connection.downlink`, or if <var>new-rtt</var> is not equal to the value of `connection.rtt`:
    1. Using the <a data-cite="!HTML#networking-task-source">networking task source</a>, <a data-cite="!HTML#queue-a-task">queue a task</a> to perform the following:
      1. Set `connection.downlinkMax` to <var>max-value</var>.
      1. Set `connection.type` to <var>new-type</var>.
      1. set `connection.effectiveType` to <var>new-effective-type</var>.
      1. Set `connection.downlink` to <var>new-downlink</var>.
      1. Set `connection.rtt` to <var>new-rtt</var>.
      1. <a data-cite="!DOM#concept-event-fire">Fire an event</a> named `change` at the `NetworkInformation` object.
</section>

## Privacy Considerations

The Network Information API exposes information about the observed network bandwidth, latency and the first network hop between the user agent and the server; specifically, the type of connection and the upper bound of the downlink speed, as well as signals whenever this information changes. Such information may be used to:

  * Fingerprint a user based on characteristics of a particular network (e.g. type and downlink estimates) at a point in time, and by observing change in such characteristics over a period of time.
  * Fingerprint a user based on transitions between one or more networks (e.g. based on order of transitions by type, downlink estimates, and time).
  * Infer user location (e.g. are they home, at work, or in transit) based on above criteria.

However, above considerations are not new, and sufficiently motivated attackers may already obtain such information using other technologies:

  * The attacker can use JavaScript to observe the duration (e.g. time from start of fetch to `onload` event) of any network fetch on the client, and may get more detailed timing data about the same fetch via the Resource Timing API.
  * The attacker can use WebRTC to identify client's public and private IP addresses via STUN, or similar mechanisms.
  * The attacker can observe the client IP, fetch duration, RTT, transfer speed, and other low-level socket metrics of a fetch on the server.

Further, by repeating one of the above strategies (e.g. via invoking periodic fetch or refresh of a resource; via periodic SSE or WebSocket messages; via periodic STUN requests, etc.), the attacker can observe changes over time in the performance characteristics of client's connection and IP address. Such data can then be used to refine the user fingerprint, infer users location (e.g. are they home, at work, or in transit), and extract various behavioral patterns.

The above list is not a complete overview. However, as the above examples illustrate, the attacks are possible both from the sender and the receiver:

  * If the attacker can initiate or observe a network fetch of any kind from the client, then they can observe its performance characteristics and how they change over time.
  * If the attacker can convince the client to fetch a resource from their server, then they can similarly observe the performance characteristics of the fetch and how they change over time.

Mitigating such attacks initiated from the client requires preventing the attacker from observing and initiating network requests - e.g., use HTTPS to prevent trivial content injection by malicious parties; disable JavaScript to prevent scripted resource fetch of any kind. Mitigating attacks from the sender is possible via the use of a VPN or an HTTP proxy - e.g. to hide the client's true IP address, to introduce additional latency, and so on.

As such, while the Network Information API makes it easier to obtain information about the first network hop, by avoiding the need to observe or make network requests, it does not expose anything that is not already available to a sufficiently-motivated attacker.

If the client wants to mitigate this class of attacks, they should disable JavaScript, monitor that all outbound requests are made to trusted origins, and make diligent use of anonymizing VPN/proxy services.

<section id="conformance">
  There is only one class of product that can claim conformance to this
  specification: a <dfn>user agent</dfn>.
</section>

<section class="appendix">
  ## Acknowledgments
  This document reuses text from the [[!HTML]] specification
  as permitted by the license of that specification.
</section>
